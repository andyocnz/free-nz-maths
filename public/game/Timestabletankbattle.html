<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Times Table Tank Battle</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        
        /* The Math Input Box */
        #math-box { 
            pointer-events: auto; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 15px; 
            box-shadow: 0 10px 25px rgba(0,0,0,0.3); text-align: center; border: 4px solid #4CAF50;
            transition: transform 0.2s; display: none;
        }
        #question { font-size: 40px; color: #333; margin-bottom: 10px; font-weight: bold; }
        #answer-input { 
            font-size: 30px; width: 120px; text-align: center; padding: 5px; border: 2px solid #ccc; border-radius: 8px; outline: none;
        }
        #answer-input:focus { border-color: #4CAF50; }
        .btn { 
            margin-top: 10px; padding: 10px 20px; font-size: 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; 
        }
        .btn:active { transform: scale(0.95); }

        /* HUD */
        #hud { position: absolute; top: 10px; width: 100%; display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box; pointer-events: none; }
        .health-bar { background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 20px; color: white; font-weight: bold; font-size: 20px; }
        .hearts { color: #ff4444; }
        #level-info { background: #fff; padding: 5px 15px; border-radius: 10px; font-weight: bold; border: 2px solid #333; }
        
        /* Messages */
        #message { 
            position: absolute; top: 20%; width: 100%; text-align: center; font-size: 50px; 
            font-weight: bold; text-shadow: 2px 2px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 10;
        }
    </style>
</head>
<body>

    <div id="hud">
        <div class="health-bar" id="p-health">Player: <span class="hearts">‚ù§‚ù§‚ù§</span></div>
        <div id="level-info">Level 1</div>
        <div class="health-bar" id="e-health">Enemy: <span class="hearts">‚ù§‚ù§‚ù§</span></div>
    </div>

    <div id="message"></div>

    <div id="ui-layer">
        <div id="math-box">
            <div id="question">2 x 2 = ?</div>
            <input type="number" id="answer-input" pattern="\d*" placeholder="?">
            <br>
            <button class="btn" id="fire-btn">FIRE! üöÄ</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * TIMES TABLE TANK BATTLE
 * A pure HTML5 Canvas game.
 */

// --- Audio System (Synthesizer) ---
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, duration, vol=0.1) {
        if (!this.ctx) this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot: function() { this.playTone(400, 'square', 0.2); this.playTone(100, 'sawtooth', 0.3); },
    playBoom: function() { this.playTone(50, 'sawtooth', 0.8, 0.3); },
    playWin: function() { 
        [523, 659, 784, 1046].forEach((f, i) => setTimeout(() => this.playTone(f, 'sine', 0.4, 0.2), i*150)); 
    },
    playWrong: function() { this.playTone(150, 'sawtooth', 0.3); }
};

// --- Game Constants & State ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiMathBox = document.getElementById('math-box');
const inputField = document.getElementById('answer-input');
const fireBtn = document.getElementById('fire-btn');
const msgEl = document.getElementById('message');
const pHealthEl = document.getElementById('p-health');
const eHealthEl = document.getElementById('e-health');
const lvlEl = document.getElementById('level-info');

let width, height;
let gameLoopId;
let state = 'START'; // START, INPUT, SHOOTING, AI_TURN, AI_SHOOTING, GAMEOVER, LEVEL_UP
let currentLevel = 1;
let score = 0;
let gravity = 0.5;

// Entities
const player = { x: 0, y: 0, w: 40, h: 20, color: '#4CAF50', hp: 3, barrelAngle: -Math.PI/4 };
const enemy = { x: 0, y: 0, w: 40, h: 20, color: '#F44336', hp: 3, barrelAngle: -3*Math.PI/4 };
let projectile = null;
let particles = [];
let currentProblem = { q: "", a: 0 };
let hills = [];

// --- Setup ---
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    generateTerrain();
    placeTanks();
}
window.addEventListener('resize', resize);

function generateTerrain() {
    hills = [];
    // Generate a nice sine-wave hill terrain
    const baseHeight = height * 0.7;
    for (let i = 0; i <= width; i+=10) {
        // Simple composition of sines for rolling hills
        let y = baseHeight + Math.sin(i * 0.005) * 100 + Math.sin(i * 0.01) * 50;
        hills.push({x: i, y: y});
    }
}

function placeTanks() {
    // Player on left hill (approx 15% width), Enemy on right (approx 85% width)
    const pIdx = Math.floor((width * 0.15) / 10);
    const eIdx = Math.floor((width * 0.85) / 10);
    
    player.x = hills[pIdx].x;
    player.y = hills[pIdx].y;
    enemy.x = hills[eIdx].x;
    enemy.y = hills[eIdx].y;
}

// --- Logic ---

function showMessage(text, color='#fff') {
    msgEl.innerText = text;
    msgEl.style.color = color;
    msgEl.style.opacity = 1;
    setTimeout(() => msgEl.style.opacity = 0, 2000);
}

function generateProblem() {
    let min=1, max=5;
    if(currentLevel === 2) { min=3; max=9; }
    if(currentLevel >= 3) { min=2; max=12; }
    
    // Boss level logic handled in game loop, numbers stay 2-12
    let n1 = Math.floor(Math.random() * (max - min + 1)) + min;
    let n2 = Math.floor(Math.random() * (max - min + 1)) + min;
    
    currentProblem = { q: `${n1} √ó ${n2} = ?`, a: n1 * n2 };
    
    document.getElementById('question').innerText = currentProblem.q;
    inputField.value = '';
    state = 'INPUT';
    uiMathBox.style.display = 'block';
    setTimeout(() => inputField.focus(), 100);
}

function fire(isPlayer, isCorrect) {
    uiMathBox.style.display = 'none';
    const shooter = isPlayer ? player : enemy;
    const target = isPlayer ? enemy : player;
    
    // Physics Calc: Calculate velocity to hit target in specific time
    // x = vx * t, y = vy * t + 0.5 * g * t^2
    const dist = target.x - shooter.x;
    const flightTime = Math.abs(dist) / 15; // Speed factor
    
    let vx = dist / flightTime;
    let vy = (target.y - shooter.y - 0.5 * gravity * flightTime * flightTime) / flightTime;

    // Adjust trajectory origin to tip of barrel
    const startX = shooter.x;
    const startY = shooter.y - 20;

    if (!isCorrect) {
        // Fail shot: short and weak
        vx *= 0.5;
        vy *= 0.5;
        AudioSys.playWrong();
    } else {
        AudioSys.playShoot();
    }

    projectile = {
        x: startX, y: startY, vx: vx, vy: vy, 
        r: 6, color: '#333', 
        owner: isPlayer ? 'player' : 'enemy',
        isDud: !isCorrect
    };
    
    state = isPlayer ? 'SHOOTING' : 'AI_SHOOTING';
}

function checkAnswer() {
    if(state !== 'INPUT') return;
    const val = parseInt(inputField.value);
    if (isNaN(val)) return;

    if (val === currentProblem.a) {
        showMessage("GREAT!", "#4CAF50");
        fire(true, true);
    } else {
        showMessage(`Miss! Answer: ${currentProblem.a}`, "#F44336");
        fire(true, false);
    }
}

// AI Turn Logic
function aiTurn() {
    state = 'AI_SHOOTING'; // Placeholder state
    setTimeout(() => {
        // AI Accuracy based on level
        // Lv 1: 50%, Lv 2: 60%, Lv 3: 70%, Lv 4+: 85%
        const chance = 0.4 + (currentLevel * 0.1);
        const hit = Math.random() < chance;
        
        fire(false, hit);
    }, 1500);
}

// Particle System
function explode(x, y, color) {
    AudioSys.playBoom();
    for(let i=0; i<20; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 1.0,
            color: color || '#FF5722'
        });
    }
}

// --- Main Loop ---
function update() {
    // Projectile Physics
    if (projectile) {
        projectile.x += projectile.vx;
        projectile.y += projectile.vy;
        projectile.vy += gravity;

        // Trail
        if(Math.random()>0.5) {
            particles.push({
                x: projectile.x, y: projectile.y, vx:0, vy:0, life: 0.5, color: '#aaa', isSmoke: true
            });
        }

        // Ground collision
        if (projectile.y > height) {
            projectile = null;
            nextTurn();
        } 
        // Tank collision
        else {
            const target = projectile.owner === 'player' ? enemy : player;
            const dx = projectile.x - target.x;
            const dy = projectile.y - target.y;
            // Simple distance check
            if (Math.sqrt(dx*dx + dy*dy) < 30) {
                // Hit!
                explode(projectile.x, projectile.y);
                if (!projectile.isDud) {
                    target.hp--;
                    updateHUD();
                    // Screen shake
                    ctx.translate(Math.random()*10-5, Math.random()*10-5);
                    setTimeout(()=>ctx.setTransform(1,0,0,1,0,0), 100);
                }
                projectile = null;
                checkWinCondition();
                if(state !== 'GAMEOVER' && state !== 'LEVEL_UP') nextTurn();
            }
        }
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;
        if(!p.isSmoke) p.vy += 0.2; // Gravity for debris
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function nextTurn() {
    if (state === 'SHOOTING') {
        state = 'AI_TURN';
        aiTurn();
    } else if (state === 'AI_SHOOTING') {
        generateProblem();
    }
}

function checkWinCondition() {
    if (player.hp <= 0) {
        state = 'GAMEOVER';
        showMessage("Try Again! üò¢", "#F44336");
        setTimeout(resetGame, 3000);
    } else if (enemy.hp <= 0) {
        AudioSys.playWin();
        if (currentLevel < 5) {
            state = 'LEVEL_UP';
            showMessage("LEVEL COMPLETE! üèÜ", "#FFD700");
            setTimeout(() => {
                currentLevel++;
                resetRound();
            }, 2500);
        } else {
            state = 'GAMEOVER';
            showMessage("YOU WON THE WAR! üéñÔ∏è", "#FFD700");
            setTimeout(resetGame, 4000); // Full reset
        }
    }
}

function resetRound() {
    player.hp = 3;
    enemy.hp = currentLevel === 5 ? 6 : 3; // Boss has double HP
    updateHUD();
    generateTerrain();
    placeTanks();
    generateProblem();
}

function resetGame() {
    currentLevel = 1;
    resetRound();
}

function updateHUD() {
    pHealthEl.innerHTML = `Player: <span class="hearts">${'‚ù§'.repeat(player.hp)}</span>`;
    eHealthEl.innerHTML = `Enemy: <span class="hearts">${'‚ù§'.repeat(enemy.hp)}</span>`;
    lvlEl.innerText = currentLevel === 5 ? "BOSS LEVEL" : `Level ${currentLevel}`;
}

// --- Drawing ---
function drawTank(t, isLeft) {
    ctx.save();
    ctx.translate(t.x, t.y);
    
    // Body
    ctx.fillStyle = t.color;
    ctx.beginPath();
    ctx.arc(0, -10, 20, Math.PI, 0); // Dome
    ctx.rect(-25, -10, 50, 15); // Chassis
    ctx.fill();
    
    // Wheels
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(-15, 5, 8, 0, Math.PI*2);
    ctx.arc(15, 5, 8, 0, Math.PI*2);
    ctx.fill();

    // Turret
    ctx.save();
    ctx.translate(0, -15);
    // Aim turret logic
    let angle = isLeft ? -Math.PI/4 : -Math.PI*0.75;
    if (state === 'SHOOTING' && isLeft && projectile) {
        // Visual flair: follow projectile slightly (omitted for simplicity, static angle is fine)
    }
    ctx.rotate(angle);
    ctx.fillStyle = '#333';
    ctx.fillRect(0, -5, 40, 10);
    ctx.restore();

    ctx.restore();
}

function draw() {
    // Sky
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, width, height);

    // Clouds
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.beginPath();
    ctx.arc(width*0.2, 100, 40, 0, Math.PI*2);
    ctx.arc(width*0.25, 80, 50, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(width*0.7, 120, 60, 0, Math.PI*2);
    ctx.fill();

    // Terrain
    ctx.fillStyle = '#689F38'; // Grass
    ctx.beginPath();
    ctx.moveTo(0, height);
    for (let p of hills) {
        ctx.lineTo(p.x, p.y);
    }
    ctx.lineTo(width, height);
    ctx.fill();

    // Tanks
    drawTank(player, true);
    drawTank(enemy, false);

    // Projectile
    if (projectile) {
        ctx.fillStyle = projectile.color;
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, projectile.r, 0, Math.PI*2);
        ctx.fill();
    }

    // Particles
    for (let p of particles) {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        const r = p.isSmoke ? 10 - (p.life*5) : 4;
        ctx.arc(p.x, p.y, r, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    // Request Next Frame
    requestAnimationFrame(loop);
}

function loop() {
    update();
    draw();
}

// --- Inputs ---
fireBtn.addEventListener('click', checkAnswer);
inputField.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') checkAnswer();
});

// Start
resize();
resetRound(); // Starts the game
loop();

</script>
</body>
</html>