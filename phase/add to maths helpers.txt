// ============================================================================
// EXACT POLAR TO RECTANGULAR (with symbolic output)
// ============================================================================

/**
 * Convert polar to rectangular with EXACT symbolic form
 * @param {number} r - modulus
 * @param {number} theta - angle coefficient (multiplied by π)
 * @returns {string} exact form like "2 + 2√3i" or "√2/2 + √2/2i"
 */
function polarToRectExact(r, theta) {
  // Normalize theta to [0, 2)
  let t = theta % 2;
  if (t < 0) t += 2;
  
  // Exact symbolic values for cos and sin at common angles
  const exactTrig = {
    0:     { cos: '1',      sin: '0' },
    1/6:   { cos: '√3/2',   sin: '1/2' },
    1/4:   { cos: '√2/2',   sin: '√2/2' },
    1/3:   { cos: '1/2',    sin: '√3/2' },
    1/2:   { cos: '0',      sin: '1' },
    2/3:   { cos: '-1/2',   sin: '√3/2' },
    3/4:   { cos: '-√2/2',  sin: '√2/2' },
    5/6:   { cos: '-√3/2',  sin: '1/2' },
    1:     { cos: '-1',     sin: '0' },
    7/6:   { cos: '-√3/2',  sin: '-1/2' },
    5/4:   { cos: '-√2/2',  sin: '-√2/2' },
    4/3:   { cos: '-1/2',   sin: '-√3/2' },
    3/2:   { cos: '0',      sin: '-1' },
    5/3:   { cos: '1/2',    sin: '-√3/2' },
    7/4:   { cos: '√2/2',   sin: '-√2/2' },
    11/6:  { cos: '√3/2',   sin: '-1/2' }
  };
  
  if (!(t in exactTrig)) {
    // Fall back to decimal if not a common angle
    const angle = theta * Math.PI;
    const a = r * Math.cos(angle);
    const b = r * Math.sin(angle);
    return formatComplex(a, b);
  }
  
  const { cos, sin } = exactTrig[t];
  
  // Multiply r by symbolic cos and sin
  const realPart = multiplySymbolic(r, cos);
  const imagPart = multiplySymbolic(r, sin);
  
  return formatComplexExact(realPart, imagPart);
}

function multiplySymbolic(r, symbolic) {
  if (symbolic === '0') return '0';
  if (symbolic === '1') return r.toString();
  if (symbolic === '-1') return (-r).toString();
  
  // Handle fractions and radicals
  if (r === 1) return symbolic;
  if (r === -1) return symbolic.startsWith('-') ? symbolic.slice(1) : '-' + symbolic;
  
  return r + symbolic;
}

function formatComplexExact(realStr, imagStr) {
  if (imagStr === '0') return realStr;
  if (realStr === '0') {
    if (imagStr === '1') return 'i';
    if (imagStr === '-1') return '-i';
    return imagStr + 'i';
  }
  
  const sign = imagStr.startsWith('-') ? ' - ' : ' + ';
  const absImag = imagStr.startsWith('-') ? imagStr.slice(1) : imagStr;
  const imagPart = absImag === '1' ? 'i' : absImag + 'i';
  
  return realStr + sign + imagPart;
}

// ============================================================================
// SOLVE DIFFERENCE OF SQUARE ROOTS
// ============================================================================

/**
 * Solve √(x + h) - √(x - k) = m
 * @param {number} h - first radical offset
 * @param {number} k - second radical offset
 * @param {number} m - result
 * @returns {string} solution as "x = ..."
 */
function solveDiffSqRoots(h, k, m) {
  // √(x + h) - √(x - k) = m
  // √(x + h) = m + √(x - k)
  // x + h = m² + 2m√(x - k) + (x - k)
  // x + h = m² + x - k + 2m√(x - k)
  // h + k - m² = 2m√(x - k)
  // (h + k - m²)² = 4m²(x - k)
  // (h + k - m²)² = 4m²x - 4m²k
  // 4m²x = (h + k - m²)² + 4m²k
  
  const A = h + k - m * m;
  const numerator = A * A + 4 * m * m * k;
  const denominator = 4 * m * m;
  
  if (denominator === 0) return "no solution (m = 0)";
  
  const x = numerator / denominator;
  
  // Verify solution (check both radicals are defined and equation holds)
  if (x + h < 0 || x - k < 0) return "no solution (domain)";
  
  const check = Math.sqrt(x + h) - Math.sqrt(x - k);
  if (Math.abs(check - m) > 1e-6) return "no solution (extraneous)";
  
  return `x = ${x}`;
}

// ============================================================================
// SIMPLIFY RATIONAL EXPRESSION
// ============================================================================

/**
 * Simplify rational expression by factoring and canceling
 * Format: (ax² + bx + c) / (dx² + ex + f)
 * @returns {string} simplified form
 */
function simplifyRational(a, b, c, d, e, f) {
  // Factor numerator: ax² + bx + c
  const numFactors = factorQuadratic(a, b, c);
  
  // Factor denominator: dx² + ex + f
  const denFactors = factorQuadratic(d, e, f);
  
  // Find and cancel common factors
  let numStr = numFactors;
  let denStr = denFactors;
  
  // Simple common factor detection (can be enhanced)
  // For now, return the factored form
  
  if (denStr === '1') return numStr;
  return `${numStr} / ${denStr}`;
}

function factorQuadratic(a, b, c) {
  if (a === 0) return b === 0 ? c.toString() : `${b}x + ${c}`;
  
  // Try to factor ax² + bx + c
  const disc = b * b - 4 * a * c;
  
  if (disc < 0) return `${a}x^2 + ${b}x + ${c}`; // Cannot factor over reals
  
  if (disc === 0) {
    const r = -b / (2 * a);
    if (a === 1) return `(x + ${-r})^2`;
    return `${a}(x + ${-r})^2`;
  }
  
  const r1 = (-b + Math.sqrt(disc)) / (2 * a);
  const r2 = (-b - Math.sqrt(disc)) / (2 * a);
  
  if (a === 1) {
    return `(x + ${-r1})(x + ${-r2})`;
  }
  return `${a}(x + ${-r1})(x + ${-r2})`;
}

// ============================================================================
// SOLVE RATIONAL EQUATION
// ============================================================================

/**
 * Solve a/(x+b) + c/(x-d) = e
 * @returns {string} solution(s) as comma-separated values
 */
function solveRationalEq(a, b, c, d, e) {
  // a/(x+b) + c/(x-d) = e
  // Multiply through by (x+b)(x-d):
  // a(x-d) + c(x+b) = e(x+b)(x-d)
  // ax - ad + cx + cb = e(x² + bx - dx - bd)
  // ax - ad + cx + cb = ex² + ebx - edx - ebd
  // 0 = ex² + (eb - ed - a - c)x + (-ebd + ad - cb)
  
  const A = e;
  const B = e * b - e * d - a - c;
  const C = -e * b * d + a * d - c * b;
  
  if (A === 0) {
    // Linear equation: Bx + C = 0
    if (B === 0) return C === 0 ? "all x ≠ -b, d" : "no solution";
    const x = -C / B;
    // Check for excluded values
    if (Math.abs(x + b) < 1e-10 || Math.abs(x - d) < 1e-10) {
      return "no solution (excluded value)";
    }
    return `x = ${x}`;
  }
  
  // Quadratic equation
  const disc = B * B - 4 * A * C;
  if (disc < 0) return "no real solution";
  
  const x1 = (-B + Math.sqrt(disc)) / (2 * A);
  const x2 = (-B - Math.sqrt(disc)) / (2 * A);
  
  const solutions = [];
  
  // Check x1
  if (Math.abs(x1 + b) > 1e-10 && Math.abs(x1 - d) > 1e-10) {
    solutions.push(x1);
  }
  
  // Check x2
  if (Math.abs(x2 + b) > 1e-10 && Math.abs(x2 - d) > 1e-10 && Math.abs(x1 - x2) > 1e-10) {
    solutions.push(x2);
  }
  
  if (solutions.length === 0) return "no solution (excluded values)";
  return solutions.map(x => `x = ${x}`).join(', ');
}

// ============================================================================
// POLYNOMIAL EVALUATION
// ============================================================================

/**
 * Evaluate cubic polynomial at k: ax³ + bx² + cx + d at x = k
 * @returns {number} result
 */
function polyEval(a, b, c, d, k) {
  return a * k * k * k + b * k * k + c * k + d;
}

// ============================================================================
// SYNTHETIC DIVISION (FULL OUTPUT)
// ============================================================================

/**
 * Perform synthetic division and return full result
 * (ax³ + bx² + cx + d) ÷ (x - k) → quotient and remainder
 * @returns {string} "quotient: ..., remainder: ..."
 */
function syntheticDivisionFull(a, b, c, d, k) {
  // Synthetic division with divisor (x - k), so use +k in algorithm
  const q2 = a;
  const q1 = b + k * q2;
  const q0 = c + k * q1;
  const r = d + k * q0;
  
  const quotient = formatPolynomial([q2, q1, q0], 2);
  
  return `quotient: ${quotient}, remainder: ${r}`;
}

function formatPolynomial(coeffs, startDegree) {
  const terms = [];
  
  for (let i = 0; i < coeffs.length; i++) {
    const coeff = coeffs[i];
    const degree = startDegree - i;
    
    if (coeff === 0) continue;
    
    let term = '';
    const absCoeff = Math.abs(coeff);
    const sign = coeff > 0 ? '+' : '-';
    
    if (terms.length > 0) term += ' ' + sign + ' ';
    else if (coeff < 0) term += '-';
    
    if (absCoeff !== 1 || degree === 0) term += absCoeff;
    
    if (degree > 0) {
      term += 'x';
      if (degree > 1) term += '^' + degree;
    }
    
    terms.push(term);
  }
  
  return terms.length > 0 ? terms.join('') : '0';
}

// ============================================================================
// COMPLETE THE SQUARE FOR CIRCLE
// ============================================================================

/**
 * Convert circle equation x² + y² + dx + ey + f = 0 to standard form
 * @param {number} d - coefficient of x
 * @param {number} e - coefficient of y
 * @param {number} f - constant term
 * @returns {string} "center: (h, k), radius: r"
 */
function completeSquareCircle(d, e, f) {
  // x² + dx + y² + ey + f = 0
  // Complete the square:
  // (x + d/2)² - (d/2)² + (y + e/2)² - (e/2)² + f = 0
  // (x + d/2)² + (y + e/2)² = (d/2)² + (e/2)² - f
  
  const h = -d / 2;
  const k = -e / 2;
  const r2 = (d * d) / 4 + (e * e) / 4 - f;
  
  if (r2 < 0) return "not a circle (negative radius squared)";
  if (r2 === 0) return `point: (${h}, ${k})`;
  
  const r = Math.sqrt(r2);
  
  return `center: (${h}, ${k}), radius: ${r}`;
}

// ============================================================================
// EXAMPLE USAGE
// ============================================================================

/*
console.log(polarToRectExact(2, 1/3));           // "1 + √3i"
console.log(solveDiffSqRoots(5, 3, 2));          // "x = ..."
console.log(simplifyRational(1, 5, 6, 1, -1, -6)); // factored form
console.log(solveRationalEq(2, 1, 3, 2, 1));     // "x = ..."
console.log(polyEval(1, -2, -5, 6, 3));          // 0 (if 3 is a root)
console.log(syntheticDivisionFull(1, -2, -5, 6, 3)); // "quotient: ..., remainder: 0"
console.log(completeSquareCircle(4, -6, 3));     // "center: (-2, 3), radius: ..."
*/